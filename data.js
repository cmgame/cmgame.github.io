var contents = new Array("灭魔王嘉妮 壁哥大法好人在做，天在看，魔王手下成祸患\n\r嘉妮装逼天地灭，赶紧消灭保平安\n\r诚心诚意壁哥好，支持壁哥平安保 \n\r众生皆为和平来，放任魔王太凶险禁言锦铎是埋没，支持魔王是大错\n\r小智壁哥说真相，叫你组队莫拒绝\n\r早日灭魔王，早日得新生\n\r\n\r\n\r\n\r创建反魔王页面:\n\r你的名字：\n\r反帮宣言：\n\r\n\r傻逼余嘉妮\n\r\n\r页面链接：\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r不要再往下拉了！\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r好吧，你拉到了最下面，然并卵。","新建项目","scr\\../../新建项目.htm","\n\r\n\rCM的下载\n\r\n\r下载\n\r\n\rCM的下载有2种途径\n\r\n\r1.百度网盘下载(http://pan.baidu.com/s/1eQEPLi6)\n\r2.群共享下载\n\r\n\r一般作者推出新版本的时候会先发在群共享然后发到百度网盘，所以如果不是群共享实在下载速度太慢，建议选择群共享下载。\n\r在群共享下载的时候要认清楚上传者应为&nbsp; 安静的沉默(2524962238)。\n\r\n\r这是0.4.6版本：\n\r\n\r注：建议下载当前的最新版本，新版本一般会修复一些bug或加入一些新功能。\n\r\n\r下载下来后解压，解压不了的话WinRAR大法！\n\r如果杀毒报毒请直接恢复+信任即可，我以沉默的人格和节操担保CM没毒。\n\r\n\r解压后是这样的（还会有一个UPX.exe）：\n\r\n\r\n\rDat则是CM的核心文件的存放目录\n\r\n\rDat目录：\n\r\n\r当然我们没有必要去更改Dat里的文件，直接打开Cmgame Maker.exe即可\n\r\n\r&nbsp;","CM的下载","scr\\CM的下载.htm","\n\r\n\r前面已经知道了自动生成的代码，那现在，我们来创建一个精灵，什么是精灵呢？可以理解为可以在屏幕上动来动去的图片吧【好不严谨的解释=。=。\n\r\n\r创建只需用这样的代码：\n\r精灵图片 =   引擎:加载图片(\"xxx.png\") --载入图片\n\r精灵1 = C_精灵.创建(精灵图片) --创建精灵\n\r但是这样只是创建了，你还是看不到它，要显示它需要在上节说到的屏幕渲染函数中添加：\n\r精灵1:显示(200,200) --注意这里和创建不同，是使用冒号不是使用点\n\r两个数字分别是x和y\n\r\n\r其他的自带组件的创建和精灵的大同小异，可以在本文档自带的支持库手册中查到关于0.4.6的基础支持库的使用方法或者在Cm左侧自带的支持库栏中查到。\n\r\n\r&nbsp;\n\r\n\r未完待续......","创建第一个精灵","scr\\创建第一个精灵.htm","\n\r\n\r一些附加的内容","附加内容","scr\\附加内容.htm","\n\r\n\r核心支持库提供了一个字节集的数据类型，从本质上来说，是一个table，里面的每一个项都是一个0到255的数字值，表示了对应的字节数据。\n\r\n\r详见支持库手册→核心支持库→字节集操作","核心库提供的字节集类型","scr\\核心库提供的字节集类型.htm","\n\r\n\r前言\n\r\n\r额，你好我是萌萌哒的RtW，这个教程是在我即将开学的时候写的，因为群内每天都会有新人加入，每天都会有新人问CM哪里下啊有没有教程啊XXX怎么用啊为什么出错了啊沉默三围多少啊之类的问题，这个教程将会对这些问题的答案进行收集（再伸手就剁手(╯‵□′)╯︵┻━┻）。以便新人能快速了解、掌握CM（顺便自己退休[才不是主要目的呢，哼]）。并会详细介绍CM自带的支持库的各个功能。\n\r\n\r下一页“CM的下载”将会告诉你怎样用正确的姿势get√Cmgame Maker并开始愉快的玩耍。\n\r\n\rCM交流群：135877988\n\r\n\r注意：本教程编写时CM的版本为0.4.6，教程内的截图、功能介绍都是基于CM0.4.6版本，请注意之后版本可能存在的功能或界面修改。\n\r注意：本教程非专业人员编写，可能会有错误或不严谨的地方，如果想获得对问题更详细、权威的解答，可以到交流群中提问或搜索\n\r注意：本教程中的代码依照CM中的默认配色方案进行配色\n\r（不要吐槽怎么注意这么多）\n\r\n\r注意：你现在看到的这个版本是未完成版本！","前言","scr\\前言.htm","\n\r\n\r这里将教你如何用CM做一个游♂戏\n\r\n\r注意：本教程虽然会简单的介绍一些Lua的用法， 但Lua不是本文的重点，若要学习Lua，可到Cm的Dat文件夹中自带的《Lua程序设计》中学习或自行到网上找学习资料","在CM中编写游戏","scr\\在CM中编写游戏.htm","\n\r\n\r创建好了游戏工程之后就能看到窗口中间的代码框里已经有一些代码，此时可以通过按下F5或点击工具栏上的来启动游戏，然后你就可以看到一个蓝色的窗口蹦了出来，这就是没有写任何代码的游戏，然并卵是不是？\n\r\n\r那么我们先理解一下CM生成的代码：\n\r\n\r在初始化屏幕下有这么一句代码：  \n\r引擎 = C_引擎.创建(\"Cmgame Maker\",60,800,600,true,true) \n\r这句代码有什么卵用呢ლ(╹◡╹ლ )？\n\r当你删掉这句代后再运行，会发现并没有创建出那个蓝色的窗口就直接运行完毕了。\n\r没错(ง •̀_•́)ง这就是创建这个窗口的指令，但创建出来的这个引擎还有其他作用，之后会再详谈。 \n\r  这里给不熟悉Lua的新人讲一个没卵用小知识：如果需要暂时让某一段代码失效，可以在代码前面加两个减号，也就是--，例如上面的代码加了之后就变成了--引擎 = C_引擎.创建(\"Cmgame Maker\",60,800,600,true,true)，变成了绿色，运行时就会跳过这句代码了(详见Lua中的注释)\n\r这句代码中的C_引擎是由核心支持库提供的数据类型，支持库可以在CM的左侧看到：\n\r\n\r然后在引擎创建下面能看到几个function，大概是这样的：\n\rfunction 屏幕逻辑 () --在接收到鼠标、键盘的输入的时候就会调用这个函数，用来处理输入、点击、按键等\n\rend\n\r\n\rfunction 屏幕渲染 () --每一帧的渲染都会调用，显示、绘画的代码只有在这下面使用才有效\n\r&nbsp;清屏(ARGB(255,64,128,192))\n\rend\n\r\n\rfunction 屏幕关闭() --当关闭游戏的时候就会调用\n\rend\n\r\n\rfunction 屏幕获得焦点()--当从其他窗口切换到游戏窗口的时候就会调用\n\rend\n\r\n\rfunction 屏幕失去焦点() --当从游戏窗口切换到其他窗口的时候就会调用 \n\rend\n\r\n\r这些是什么呢( ◔ ڼ ◔ )？在特定情况下CM就会调用这些函数，只需把代码写在从function那一行到end之间就会被调用\n\r这些情况已经在上面代码里标注了。\n\r\n\r\n\r\n\r\n\r\n\r上面的代码里可以看到有一句：\n\r清屏(ARGB(255,64,128,192))\n\r这又有什么卵用呢ლ(╹◡╹ლ )？卵用大着呢。\n\r顾名思义，就是用来清屏用的，会清除已经画出来的东西，因为上一帧绘画的内容会一直存在，所以必须用这个指令清掉。\n\r如果不清掉的话，静止的东西也许不会发生什么，但动的东西就会有长长的残影~\n\r所以建议在最上面保持有一句清屏为好\n\r当然如果你能保证你什么时候都能让全屏都画满东西（比如弄张背景图）的话，也可以去掉清屏。\n\r\n\r清屏的使用方法是：清屏([数值型]颜色)\n\r那么问题来了(￣△￣；) ：上面那句清屏中的ARGB是什么鬼？\n\r\n\rARGB是四个词的简写，分别是Alpha(阿尔法通道)、Red(红色通道)、Green(绿色通道)、Blue(蓝色通道)\n\r阿尔法通道决定透明度，其他三个分别决定对应的颜色的含量\n\r\n\rARGB的用法是：ARGB([数值型]Alpha,[数值型]红,[数值型]绿,[数值型]蓝)\n\r\n\r提供的四个参数的值均为0到255之间的数字，代表含量。\n\rAlpha值越接近0越透明，越接近255越不透明，255为完全不透明。\n\r其他三个值越接近0越暗，越接近255越亮。\n\r附：从CM自动生成的代码的清屏颜色（ARGB(255,64,128,192)）到完全透明（ARGB(0,64,128,192)）的示意图：\n\r","认识自动生成的代码","scr\\在CM中编写游戏/开始写代码.htm","\n\r\n\r想要新建一个游戏工程，可以点击菜单 -&gt; 文件 -&gt; 新建工程，也可以直接点击菜单下面的工具栏的第一个按钮来创建一个新工程    \n\r\n\r点击后会出现这样的一个窗口：\n\r\n\r创建一个游戏只需选择[C.M 游戏]，然后输入名称并选择目录，最后点击确定就ok啦。\n\r注：CM在创建游戏的时候会为游戏创建目录，所以上图的游戏会被存储到“D:\\My Documents\\桌面\\演示项目”文件夹中    ","新建一个游戏","scr\\在CM中编写游戏/新建一个游戏.htm","\n\r\n\r介绍了支持库的各个指令和数据类型\n\r版本为0.4.6，新版本可能会有不同","支持库手册","scr\\支持库手册.htm","\n\r\n\r支持库名称:核心支持库\n\r版本: 0.4.6\n\r简介: 本支持库实现了基础的渲染底层。\n\r作者: Cmgame Maker\n\r版权声明: Cmgame Maker  ","核心支持库","scr\\支持库手册/核心支持库.htm","\n\r\n\r所属类库: 核心支持库 &gt; Lua核心方法 - 调试输出\n\r调用格式: 调试输出([通用型]欲输出内容)\n\r函数返回: [无]\n\r备注说明: 输出调试内容\n\r\n\r等同于print，可以用print实现相同效果。","调试输出","scr\\支持库手册/核心支持库/Lua核心方法/调试输出.htm","\n\r\n\r所属类库: 核心支持库 &gt; Lua核心方法 - 执行脚本文本\n\r调用格式: 执行脚本文本([文本型]欲执行代码)\n\r函数返回: [无]\n\r备注说明: 执行lua脚本文本\n\r\n\r执行提供的lua代码，因为需要在执行过程中编译这部分代码所以可能会降低效率。\n\r\n\r等同于loadstring，可以用loadstring([文本型]欲执行代码)()来实现相同效果。\n\r注意！上面的代码最后还有一对括号，这对括号的意义是执行loadstring的返回值，因为loadstring返回的是一个function，再加上一个括号就代表执行这个function。所以可以利用这个特性将loadstring返回的function保存到变量中，在需要的时候执行。","执行脚本文本","scr\\支持库手册/核心支持库/Lua核心方法/执行脚本文本.htm","\n\r\n\r所属类库: 核心支持库 &gt; Lua核心方法 - 执行脚本文件\n\r调用格式: 执行脚本文件([文本型]文件路径)\n\r函数返回: [无]\n\r备注说明: 执行外部lua脚本文件\n\r\n\r载入脚本文件并执行，因为需要在执行过程中编译这部分代码所以可能会降低效率。\n\r\n\r等同于dofile，可用dofile([文本型]文件路径)实现相同效果","执行脚本文件","scr\\支持库手册/核心支持库/Lua核心方法/执行脚本文件.htm","\n\r\n\r所属类库: 核心支持库 &gt; 数据类型 - C_引擎 - 创建\n\r调用格式: 对象.创建([文本型]窗口标题,[数值型]刷新频率,[数值型]屏幕宽度,[数值型]屏幕高度,[逻辑型]是否显示鼠标,[逻辑型]是否窗口化,[逻辑型]是否有边框,[文本型]窗口小图标路径)\n\r函数返回: [无]\n\r备注说明: 创建并初始化一个CM脚本游戏引擎接口.\n\r\n\r\n\r调用这个指令会创建一个游戏窗口。\n\r一般创建新项目就会自带一句：\n\r引擎 = C_引擎.创建(\"Cmgame Maker\"       , 60 ,800,600,true,true) \n\r可修改这一句，比如修改标题为“Cm大法好”，大小改为640x480，并修改为不显示鼠标，那这一句就变成：\n\r引擎 = C_引擎.创建( \"Cm大法好\"       , 60 ,640,480,false,true) ","创建","scr\\支持库手册/核心支持库/数据类型/C_引擎/创建.htm","所属类库: 核心支持库 &gt; 数据类型 - C_引擎 - 取按键按下\n\r调用格式: 对象:取按键按下([数值型]键值标识)\n\r函数返回: [逻辑型]是否按下\n\r备注说明: 判断指定按键是否按下. *注意:只检测一次.\n\r\n\r\n\r检测某个按键在检测的瞬间是否被同时按下，返回的是一种动作的发生与否，检测瞬间被同时按下返回true，否则返回false","取按键按下","scr\\支持库手册/核心支持库/数据类型/C_引擎/取按键按下.htm","所属类库: 核心支持库 &gt; 数据类型 - C_引擎 - 取按键弹起\n\r调用格式: 对象:取按键弹起([数值型]键值标识)\n\r函数返回: [逻辑型]是否弹起\n\r备注说明: 判断指定按键是否弹起. *注意:只检测一次.\n\r\n\r\n\r检测某个按键在检测的瞬间是否被同时弹起，返回的是一种动作的发生与否，检测瞬间被同时弹起返回true，否则返回false\n\r\n\r&nbsp;","取按键弹起","scr\\支持库手册/核心支持库/数据类型/C_引擎/取按键弹起.htm","\n\r\n\r所属类库: 核心支持库 &gt; 数据类型 - C_引擎 - 取按键事件\n\r调用格式: 对象:取按键事件([数值型]键值标识)\n\r函数返回: [逻辑型]是否按下\n\r备注说明: 持续检测指定键值的按下弹起事件. *注意:持续检测 .\n\r\n\r键值标识在公开常量里可以找到，以“键_”开头\n\r\n\r返回的是某个按键是否为按住的状态，即一种状态。按住为true，否则为false。","取按键事件","scr\\支持库手册/核心支持库/数据类型/C_引擎/取按键事件.htm","\n\r\n\r所属类库: 核心支持库 &gt; 数据类型 - C_引擎 - 取滚轮事件\n\r调用格式: 对象:取滚轮事件()\n\r函数返回: [数值型]滚轮状态\n\r              备注说明: 返回鼠标滚轮状态值,向上滚动返回正数,向下返回负数.\n\r\n\r返回的是滚轮的滚动距离，注意向上滚动返回正，向下滚动返回负。","取滚轮事件","scr\\支持库手册/核心支持库/数据类型/C_引擎/取滚轮事件.htm","\n\r\n\r所属类库: 核心支持库 &gt; 数据类型 - C_引擎 - 取屏幕鼠标坐标\n\r调用格式: 对象:取屏幕鼠标坐标()\n\r函数返回: [数值型]鼠标坐标X,[数值型]鼠标坐标Y\n\r备注说明: 取鼠标在屏幕上的坐标,返回两个参数,X和Y\n\r\n\r返回的坐标是以屏幕为原点的，也就是鼠标在屏幕上的坐标\n\r\n\r返回值是两个参数，多参数在取鼠标坐标中有简单介绍。","取屏幕鼠标坐标","scr\\支持库手册/核心支持库/数据类型/C_引擎/取屏幕鼠标坐标.htm","\n\r\n\r所属类库: 核心支持库 &gt; 数据类型 - C_引擎 - 取鼠标坐标\n\r调用格式: 对象:取鼠标坐标()\n\r函数返回: [数值型]鼠标坐标X,[数值型]鼠标坐标Y\n\r备注说明: 取鼠标在窗口内的坐标,返回两个参数,X和Y\n\r\n\r返回的坐标是相对于窗口原点的，也就是在窗口内的坐标。\n\r\n\r返回值为两个参数，所以要存在变量中的话，需要同时提供两个参数\n\r例如：\n\rmouseX , mouseY = 引擎:取鼠标坐标() \n\r\n\r如果是作为函数的参数的，那么函数将同时接到两个参数\n\r例如：\n\rfunction 测试(mouseX,mouseY) --这里声明了两个参数\n\r　　调试输出(\"鼠标x坐标：\",mouseX,\"鼠标y坐标：\",mouseY)\n\rend\n\r测试(引擎 :取鼠标坐标())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --直接传入取鼠标坐标，无需分别传入两个参数\n\r\n\r如果只需要其中一个参数，那么可以使用哑元，直接用下划线代替变量名来表示不需要此返回值\n\r例如：\n\r_ , mouseY = 引擎:取鼠标坐标()&nbsp;--无视第一个参数\n\rmouseX&nbsp; , _  =   引擎:取鼠标坐标() --无视第二个参数\n\r\n\r如果需要将结果保存到table中，可以这么写：\n\rmouseXY =  {引擎 :取鼠标坐标 ()}\n\r调试输出 (mouseXY[1]) --输出鼠标x坐标，也就是第一个参数\n\r调试输出 (mouseXY[2]) --输出鼠标y坐标，也就是第二个参数","取鼠标坐标","scr\\支持库手册/核心支持库/数据类型/C_引擎/取鼠标坐标.htm","\n\r\n\r所属类库: 核心支持库 &gt; 数据类型 - C_引擎 - 取最后帧时间\n\r调用格式: 对象:取最后帧时间()\n\r函数返回: [数值型]帧时间\n\r备注说明: 返回最后帧更新时间.结果通常为1/帧率.\n\r\n\r返回的是最后一帧的渲染耗时（？），如果这个数字大于1/帧率的话，就说明掉帧了。\n\r当然这个不是最好的检测掉帧的方法，可以使用“取FPS”更直接的获取到帧率进行比对。\n\r\n\r注意：CM例程中常常将此作为时间的依据，这是我个人不推荐的，因为如果这么做的话，卡顿的时候动作速度会变慢，如果用在跳跃中还会导致跳跃高度或距离缩小（因为这么做的话距离与会帧率相关），这些问题在网游中是致命的，在单机游戏中也不容小视，而如果直接锁定速度为1/帧率还是解决不了卡顿时的速度问题（因为无法跳帧）。\n\r\n\r下一版的教程会介绍一个比较好的解决方案【天国の下一版TAT","取最后帧时间","scr\\支持库手册/核心支持库/数据类型/C_引擎/取最后帧时间.htm","\n\r\n\r所属类库: 核心支持库 &gt; 数据类型 - C_引擎 - 销毁图片\n\r调用格式: 对象:销毁图片([数值型]图片指针)\n\r函数返回: [无]\n\r备注说明: 销毁指定图片资源，释放内存.\n\r\n\r如果图片在不会再次使用的情况下就可以调用这个函数来销毁图片资源。","销毁图片","scr\\支持库手册/核心支持库/数据类型/C_引擎/销毁图片.htm","\n\r\n\r所属类库: 核心支持库 &gt; 数据类型 - C_引擎 - 载入图片\n\r调用格式: 对象:载入图片([文本型]图片路径,[整数型]透明色)\n\r函数返回: [数值型]图片指针\n\r备注说明: 载入图片\n\r\n\r载入图片，返回的不是图片而是图片指针，编译后的游戏必须手动把使用到的图片丢到游戏目录下。\n\r\n\r和载入图片_字节集功能相同，只是载入的是文件。\n\r\n\r在不需要用到这个图片的时候，最好调用销毁图片来释放内存。","载入图片","scr\\支持库手册/核心支持库/数据类型/C_引擎/载入图片.htm","\n\r\n\r所属类库: 核心支持库 &gt; 数据类型 - C_引擎 - 载入图片_字节集\n\r调用格式: 对象:载入图片([字节集]字节集数据,[整数型]透明色)\n\r函数返回: [数值型]图片指针\n\r备注说明: \n\r\n\r和载入图片功能相同，只是载入的是字节集数据而不是文件。\n\r\n\r在不需要用到这个图片的时候，最好调用销毁图片来释放内存。","载入图片_字节集","scr\\支持库手册/核心支持库/数据类型/C_引擎/载入图片_字节集.htm","\n\r\n\r所属类库: 核心支持库 &gt; 数据类型 - C_引擎 - 置帧率\n\r调用格式: 对象:置帧率([数值型]帧率)\n\r函数返回: [无]\n\r备注说明: 动态改变FPS\n\r\n\r可以在游戏中途改变FPS，假设引擎被创建在“引擎”变量里，那么需要调节FPS为15就这么使用：\n\r引擎:置帧率 ( 15)","置帧率","scr\\支持库手册/核心支持库/数据类型/C_引擎/置帧率.htm");